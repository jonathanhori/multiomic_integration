---
title: "Modeling"
author: "Jonathan Hori"
date: "2025-10-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# From GitHub - requires devtools
# devtools::install_github("niccoloanceschi/jafar")


library(jafar)
library(Rfast)
library(ggplot2)
library(pROC)
library(tidyverse)
library(latex2exp)

source("../R/data_methods.R")

jafar_data <- Data

output_dir = "./results/"
dir.create(output_dir) #, showWarnings = FALSE)
# getwd()
```

MCMC params
```{r}
tMCMC = 10000
tBurnIn = 5000
tThin = 10

mcmc_seed=1234
```

# Data preprocessing

```{r}
# sample_ix <- sample(1:500, size = 100)

# sim_data <- readRDS("./data/sim_data_n100_snr1.1.rds")
# sim_data <- readRDS("./data/sim_data_n100_snr1.1_ywithview.rds")
# sim_data <- readRDS("./data/sim_data_n100_snr2.2_ywithview.rds")
# sim_data <- readRDS("./data/sim_data_n100_snr2.2_ywithview_sparseloadings.rds") 
# sim_data <- readRDS("./data/sim_data_n100p100_snr2.2_ywithview.rds") 
sim_data <- readRDS("./data/sim_data_n1000p50_snr2.2_ywithview.rds") 

X_l <- sim_data$X_l
# readRDS("./data/sim_data_x.rds") |> 
  # lapply(function(x) x[sample_ix, ])
y <- sim_data$y
  # eadRDS("./data/sim_data_y.rds")[sample_ix]
```



```{r}
X_l.clean <- standardize_views(X_l)
y.clean <- standardize_outcome(y)
```


# JAFAR
MCMC params


## Single run
```{r}
system.time({
mcmc_supervised <- gibbs_jafar(X_m = X_l.clean, 
                               y = y.clean, 
                               # K0=K0, 
                               K0_m=c(10, 10, 10),
                               tMCMC=tMCMC, 
                               tBurnIn=tBurnIn, 
                               tThin=tThin,
                               hyperparams = list(seed = mcmc_seed))
})
```

For 
N = 100
tMCMC = 10000
tBurnIn = 5000
tThin = 10

   user  system elapsed 
699.293 104.625 415.154 




### MatchAlign

```{r}
plot_loadings(mcmc_supervised,
              out_path = output_dir,
              out_shared = paste0(format(Sys.time(), "%m%d%y_%H%M"), "_shared_loadings"), 
              out_specific = paste0(format(Sys.time(), "%m%d%y_%H%M"), "_specific_loadings"))
```


```{r}
mcmc_supervised <- multiviewMatchAlign(mcmc_supervised)
```


## Evaluate performance

### Structure reconstruction
Check reconstruction of shared and view-specific structure, which should be uniquely identified, unlike individual loading/score matrices.


```{r}


jafar_posterior_means <- calc_jafar_posterior_means(mcmc_supervised)

# jafar_loadings.shared <- lapply(mcmc_supervised$Lambda_m,
#        function(mat) {
#          apply(mat, c(2, 3), mean)
#        })
# 
# jafar_loadings.view_specific <- lapply(mcmc_supervised$Gamma_m,
#        function(mat) {
#          apply(mat, c(2, 3), mean)
#        })
# 
# 
# jafar_scores.shared <- apply(mcmc_supervised$eta, c(2, 3), mean)
# 
# jafar_scores.view_specific <- lapply(mcmc_supervised$phi_m,
#        function(mat) {
#          apply(mat, c(2, 3), mean)
#        })

```


Compute latent structures

```{r}

```


```{r}
est_obj <- calc_all_structures(jafar_posterior_means$shared_scores,
                               jafar_posterior_means$view_scores,
                               jafar_posterior_means$shared_loadings,
                               jafar_posterior_means$view_loadings)

sim_obj <- calc_all_structures(sim_data$Z,
                               sim_data$Phi,
                               sim_data$Lambda_l,
                               sim_data$Gamma_l)
```

```{r}
jafar_structure.shared <- lapply(1:length(jafar_loadings.shared), 
       function(l) {
         compute_structure(jafar_scores.shared,
                           jafar_loadings.shared[[l]])
       }
)

jafar_structure.view_specific <- lapply(1:length(jafar_scores.view_specific), 
       function(l) {
         compute_structure(jafar_scores.view_specific[[l]],
                           jafar_loadings.view_specific[[l]])
       }
)

jafar_structure.reconstructed <- lapply(1:length(jafar_structure.shared), 
       function(l) {
         jafar_structure.shared[[l]] + jafar_structure.view_specific[[l]]
       }
)
```

```{r}
sim_structure.shared <- lapply(1:sim_data$L, 
       function(l) {
         compute_structure(sim_data$Z,
                           sim_data$Lambda_l[[l]])
       }
)

sim_structure.view_specific <- lapply(1:sim_data$L, 
       function(l) {
         compute_structure(sim_data$Phi[[l]],
                           sim_data$Gamma_l[[l]])
       }
)

sim_structure.reconstructed <- lapply(1:sim_data$L, 
       function(l) {
         compute_structure(sim_data$Z,
                           sim_data$Lambda_l[[l]]) + 
           compute_structure(sim_data$Phi[[l]],
                           sim_data$Gamma_l[[l]])
       }
)
```




```{r}
# est_obj <- list(
#   joint_structure = lapply(1:length(jafar_loadings.shared), 
#                            function(l) {
#                              compute_structure(jafar_scores.shared,
#                                                jafar_loadings.shared[[l]])
#                            }
#   ),
#   view_structure = lapply(1:length(jafar_scores.view_specific), 
#                           function(l) {
#                             compute_structure(jafar_scores.view_specific[[l]],
#                                               jafar_loadings.view_specific[[l]])
#                           }
#   ),
#   data_reconstruction = lapply(1:length(jafar_structure.shared), 
#                                function(l) {
#                                  compute_structure(jafar_scores.shared,
#                                                    jafar_loadings.shared[[l]]) + 
#                                    compute_structure(jafar_scores.view_specific[[l]],
#                                                      jafar_loadings.view_specific[[l]])
#                                }
#   )
# )

# sim_obj <- list(
#   joint_structure = lapply(1:sim_data$L, 
#                            function(l) {
#                              compute_structure(sim_data$Z,
#                                                sim_data$Lambda_l[[l]])
#                            }
#   ),
#   view_structure = lapply(1:sim_data$L, 
#                           function(l) {
#                             compute_structure(sim_data$Phi[[l]],
#                                               sim_data$Gamma_l[[l]])
#                           }
#   ),
#   data_reconstruction = lapply(1:sim_data$L, 
#                                function(l) {
#                                  compute_structure(sim_data$Z,
#                                                    sim_data$Lambda_l[[l]]) + 
#                                    compute_structure(sim_data$Phi[[l]],
#                                                      sim_data$Gamma_l[[l]])
#                                }
#   )
# )
```



## Eval

Relative squared error in structures:

$$
\lVert\hat S_{shared} - S_{shared}\rVert^2 = \lVert\hat Z\hat\Lambda^{(l)T} - Z\Lambda^T\rVert^2 \\
\frac{\lVert\hat S - S\rVert^2}{\lVert S\rVert^2}
$$
```{r}
lapply(1:sim_data$L,
       function(l) {
         norm(jafar_structure.shared[[l]] - 
                sim_structure.shared[[l]], type = "F") ^ 2 /
           norm(sim_structure.shared[[l]]) ^2
       })


lapply(1:sim_data$L,
       function(l) {
         norm(jafar_structure.view_specific[[l]] - 
                sim_structure.view_specific[[l]], type = "F") ^ 2 /
           norm(sim_structure.shared[[l]]) ^2
       })

```

```{r}
jafar_structure.shared[[l]] |> 
  as_tibble() |> 
  mutate(n = row_number()) |> 
  pivot_longer(c(everything(), -n)) |> 
  ggplot() +
  geom_tile(aes(y = n, x = name, fill = value)) +
  scale_fill_gradient2(low = "red", high = "blue", mid = "white")

sim_structure.shared[[l]] |> 
  as_tibble() |> 
  mutate(n = row_number()) |> 
  pivot_longer(c(everything(), -n)) |> 
  ggplot() +
  geom_tile(aes(y = n, x = name, fill = value)) +
  scale_fill_gradient2(low = "red", high = "blue", mid = "white")



(jafar_structure.shared[[l]] - 
                sim_structure.shared[[l]]) |> summary() |> list()


for (l in 1:3) {
print((jafar_structure.shared[[l]] - 
                sim_structure.shared[[l]]) |> 
  as_tibble() |> 
  mutate(n = row_number()) |> 
  pivot_longer(c(everything(), -n)) |> 
  ggplot() +
  geom_tile(aes(y = n, x = name, fill = value)) +
  scale_fill_gradient2(low = "red", high = "blue", mid = "white") 
)
    
}
```


Difference in covariance

$$
\lVert\hat \Lambda^{(l)}\hat \Lambda^{(l)T} - \Lambda^{(l)}\Lambda^{(l)T} \rVert^2
$$

```{r}

lapply(1:sim_data$L,
       function(l) {
         norm(sim_data$Lambda_l[[l]] %*% t(sim_data$Lambda_l[[l]]) - 
                jafar_loadings.shared[[l]] %*% t(jafar_loadings.shared[[l]]), 
              type = "F") ^ 2
       })
```

```{r}
l = 1
chol(sim_data$Lambda_l[[l]] %*% t(sim_data$Lambda_l[[l]]))

diag(sim_data$Lambda_l[[l]] %*% t(sim_data$Lambda_l[[l]]))
```


### Data reconstruction

$$
\frac{\lVert\hat X^{(l)} - X^{(l)}\rVert^2}{\lVert X^{(l)}\rVert^2} \\
\lVert\hat X^{(l)} - X^{(l)}\rVert^2
$$
```{r}
# Sanity check: Verify simulated data structures reconstruct data
print("Relative squared error")
lapply(1:sim_data$L,
       function(l) {
         norm(sim_structure.reconstructed[[l]] - 
                X_l[[l]], type = "F") ^ 2 /
           norm(X_l[[l]]) ^2
       })

print("Difference norm")
lapply(1:sim_data$L,
       function(l) {
         norm(sim_structure.reconstructed[[l]] - 
                X_l[[l]], type = "F") ^ 2
       })

```

```{r}
print("Relative squared error")
lapply(1:sim_data$L,
       function(l) {
         return(list(l = l,
                     rse = 
         norm(sim_structure.reconstructed[[l]] - 
                jafar_structure.reconstructed[[l]], type = "F") ^ 2 /
           norm(sim_structure.reconstructed[[l]], type = "F") ^2
         ))
       }) |> bind_rows()

print("Difference norm")
lapply(1:sim_data$L,
       function(l) {
         norm(sim_structure.reconstructed[[l]] - 
                jafar_structure.reconstructed[[l]], type = "F") ^ 2
       })
```


```{r}


# testing <- function(quantity){
#   sim_quantity = switch(quantity,
#                          joint_structure = {sim_obj$joint_structure},
#                          view_structure = {sim_obj$view_structure},
#                          data_reconstruction = {sim_obj$data_reconstruction})
#   est_quantity = switch(quantity,
#                          joint_structure = {est_obj$joint_structure},
#                          view_structure = {est_obj$view_structure},
#                          data_reconstruction = {est_obj$data_reconstruction})
#   return(est_quantity)
#   # lapply(1:3,
#   #        function(l){
#   #          return(sim_quantity[[l]] - est_quantity[[l]])
#   #        })
# }
# 
# es
# 
# a = testing("joint_structure")
# c(
# eval_model(est_obj,
#            sim_obj,
#            "joint_structure",
#            "rse") ,
# eval_model(est_obj,
#            sim_obj,
#            "view_structure",
#            "rse")
# ) |> bind_rows()
```


```{r}
bind_rows(
  eval_model(est_obj,
           sim_obj,
           "joint_structure",
           "rse"),
  eval_model(est_obj,
           sim_obj,
           "view_structure",
           "rse"),
  eval_model(est_obj,
           sim_obj,
           "data_reconstruction",
           "rse"),
) |> 
  mutate(n = 1000,
         p = 50,
         snr_x = 2,
         snr_y = 2) |>
  print() |> 
  ggplot() +
  geom_boxplot(aes(x = n,
                 y = result,
                 group = quantity,
                 color = quantity)) #|> 
  facet_grid(rows = vars())


```


### Outcome model coefficients

```{r}
colMeans(mcmc_supervised$Theta)
beta_sim
```



### Outcome prediction

```{r}
y_pred <- predict_y(X_l.clean, mcmc_supervised)

plot_predictions(y_pred, y.clean, mcmc_supervised, 
                 out_path=output_dir, out_name="preds_sim4")
```

```{r}
# knitr::include_graphics(file.path(output_dir,'predictions.pdf'))
```

```{r}
plot_coefficients(y_pred)
```


Evaluate prediction AUC

```{r}
y_pred.means <- colMeans(y_pred$mean)
```


```{r}
# y.clean
tibble(pred = y_pred.means,
       outcome = y.clean) |> 
  # filter(outcome < -2.23)

  ggplot(aes(x = outcome, y = pred)) +
  geom_point() +
  stat_smooth(method = lm) + 
  labs(x = "Simulated outcome",
       y = "Predicted outcome")
```



```{r}
df_ref

df_plot
```


# Multiple datasets

```{r}
n_array <- c(50, 100, 500, 1000, 5000)
p_array <- c(50, 100, 1000, 10000)
snr_x_array <- c(2, 1, 0.5)
snr_y_array <- c(2, 1, 0.5)
reps = 10

sim_grid <- expand.grid(n = n_array,
            p_l = p_array,
            snr_x = snr_x_array,
            snr_y = snr_y_array,
            rep = 1:10)

data_name_base <- "sim_data_ywithview_rep%s.rds"
data_path_base <- file.path(dirname(rstudioapi::getSourceEditorContext()$path), 
                      "data",
                      "n%sp%s_snr%s.%s")

out_path_base <- file.path(dirname(rstudioapi::getSourceEditorContext()$path), 
                           "results",
                           "jafar")
out_name_base <- "n%sp%s_snr%s.%s_rep%s.rds"


log_dir <- "logs"

log_message <- function(...) {
  msg <- paste(Sys.time(), paste(..., collapse = " "), "\n")
  cat(msg, file = log_file, append = TRUE)
}
```


Raw code below. Attempting to parallelize below this.
```{r}
eval_table.collected <- tibble()
mcmc_objects <- list()

mapply(function(n, p, snr_x, snr_y) {
  for (rep in 1:reps) {
    # Load + process data
    run_data <- load_data(n, p, snr_x, snr_y, rep)
    X_l <- run_data$X_l
    y <- run_data$y
    X_l.clean <- standardize_views(X_l)
    y.clean <- standardize_outcome(y)
    
    # use default K0. 
    # FIT MODEL
    tik <- Sys.time()
    mcmc_supervised <- gibbs_jafar(X_m = X_l.clean, 
                                   y = y.clean, 
                                   # K0=K0, 
                                   # K0_m=c(10, 10, 10),
                                   tMCMC=tMCMC, 
                                   tBurnIn=tBurnIn, 
                                   tThin=tThin,
                                   hyperparams = list(seed = mcmc_seed))
    tok <- Sys.time()
    runtime <- tok - tik
    
    # Average over MCMC samples
    jafar_posterior_means <- calc_jafar_posterior_means(mcmc_supervised)
    
    # Calculate structures from fitted model and simulated data
    est_obj <- calc_all_structures(jafar_posterior_means$shared_scores,
                                   jafar_posterior_means$view_scores,
                                   jafar_posterior_means$shared_loadings,
                                   jafar_posterior_means$view_loadings)
    
    sim_obj <- calc_all_structures(run_data$Z,
                                   run_data$Phi,
                                   run_data$Lambda_l,
                                   run_data$Gamma_l)
    
    eval_table <- bind_rows(
      eval_model(est_obj,
                 sim_obj,
                 "joint_structure",
                 "rse"),
      eval_model(est_obj,
                 sim_obj,
                 "view_structure",
                 "rse"),
      eval_model(est_obj,
                 sim_obj,
                 "data_reconstruction",
                 "rse"),
    ) |> 
      mutate(n = n,
             p = p,
             snr_x = snr_x,
             snr_y = snr_y,
             rep = rep,
             time = as.numeric(difftime(tok, tik, units = "secs")))
    
    eval_table.collected <- bind_rows(eval_table.collected,
                                      eval_table)
    mcmc_objects[paste0("n", n, "p", p, "snrx", snr_x, "snry", snr_y, "rep", rep)] <- mcmc_supervised
  }
},
sim_grid$n,
sim_grid$p_l,
sim_grid$snr_x,
sim_grid$snr_y)
```

```{r}
run_and_eval_model <- function(n, p, snr_x, snr_y, rep,
                               in_path_base,
                               in_name_base,
                               out_path_base,
                               out_name_base) {
  model_out_data_path <- file.path(out_path_base,
                             "models",
                             sprintf(out_name_base,  n, p, snr_x, snr_y, rep))
  # Skip dataset if model already run
  if (file.exists(model_out_data_path)) {NA}
  else {
  
  # n <- params$n
  # p <- params$p
  # snr_x <- params$snr_x
  # snr_y <- params$snr_y
  
  # Load + process data
  run_data <- load_data(in_path_base, in_name_base,
                        n, p, snr_x, snr_y, rep)
  X_l <- run_data$X_l
  y <- run_data$y
  X_l.clean <- standardize_views(X_l)
  y.clean <- standardize_outcome(y)
  
  # use default K0. 
  # FIT MODEL
  tik <- Sys.time()
  tryCatch({
  mcmc_supervised <- gibbs_jafar(X_m = X_l.clean, 
                                 y = y.clean, 
                                 # K0=K0, 
                                 # K0_m=c(10, 10, 10),
                                 tMCMC=tMCMC, 
                                 tBurnIn=tBurnIn, 
                                 tThin=tThin,
                                 hyperparams = list(seed = mcmc_seed))
  }, error = function(e) {
    message(e)
    log_message(e)
  })
  tok <- Sys.time()
  runtime <- tok - tik
  
  # Export model
  # model_out_data_path <- file.path(out_path_base,
  #                            "models",
  #                            sprintf(out_name_base,  n, p, snr_x, snr_y, rep))
  log_message("Writing model:", as.character(model_out_data_path))
  saveRDS(mcmc_supervised,
          model_out_data_path)
  
  tryCatch({
    # log_message("Evaluating metrics")
  # Average over MCMC samples
    # log_message("→ calc_jafar_posterior_means")
  jafar_posterior_means <- calc_jafar_posterior_means(mcmc_supervised)
  
  # Calculate structures from fitted model and simulated data
  # log_message("→ calc_all_structures est_obj")
  est_obj <- calc_all_structures(jafar_posterior_means$shared_scores,
                                 jafar_posterior_means$view_scores,
                                 jafar_posterior_means$shared_loadings,
                                 jafar_posterior_means$view_loadings)
  # log_message("→ calc_all_structures sim_obj")
  sim_obj <- calc_all_structures(run_data$Z,
                                 run_data$Phi,
                                 run_data$Lambda_l,
                                 run_data$Gamma_l)
   
  # log_message("→ eval_model + bind_rows")
  eval_table <- bind_rows(
    eval_model(est_obj,
               sim_obj,
               "joint_structure",
               "rse"),
    eval_model(est_obj,
               sim_obj,
               "view_structure",
               "rse"),
    eval_model(est_obj,
               sim_obj,
               "data_reconstruction",
               "rse"),
  ) |> 
    mutate(n = n,
           p = p,
           snr_x = snr_x,
           snr_y = snr_y,
           rep = rep,
           time = as.numeric(difftime(tok, tik, units = "secs")))
  
  
  ### Export results
  # eval_table.collected <- bind_rows(eval_table.collected,
  #                                   eval_table)
  metric_out_data_path <- file.path(out_path_base,
                             "metrics",
                             sprintf(out_name_base,  n, p, snr_x, snr_y, rep))
  log_message("Writing metrics:", as.character(metric_out_data_path))
  dir.create(dirname(metric_out_data_path), recursive = TRUE, showWarnings = TRUE)
  stopifnot(exists("eval_table"))
  
  saveRDS(eval_table,
          metric_out_data_path)
  }, error = function(e) {
    message(e)
    log_message(e)
  })
  }
  
}
```


```{r}

test_run_and_eval_model <- function(n, p, snr_x, snr_y, rep,
                                    in_path_base,
                                    in_name_base,
                                    out_path_base,
                                    out_name_base) {
  log_message("Starting run")
  load_data(in_path_base, in_name_base,
            n, p, snr_x, snr_y, rep)
  log_message("data loaded")
  
  log_message(paste0(n, p, snr_x, snr_y, rep))
  eval_table <- tibble(c(n, p, snr_x, snr_y, rep))
  log_message(paste0(out_path_base, "mod_n", n, "p", p, "snrx", snr_x, "snry", snr_y, "rep", rep))
  
  saveRDS(eval_table, 
          paste0(out_path_base, "/mod_n", n, "p", p, "snrx", snr_x, "snry", snr_y, "rep", rep, ".RDS"))
}


```

Fit JAFAR in parallel
```{r}
library(foreach)
library(doParallel)
```

```{r}
n_cores <- detectCores()
n_cores

# cluster <- makeCluster(n_cores - 1)
# registerDoParallel(cluster)
```

```{r}

cluster <- makeCluster(n_cores - 1)
registerDoParallel(cluster)

timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
dir.create(log_dir, showWarnings = FALSE)
log_file <- file.path(log_dir, paste0("run_", timestamp, ".log"))
file.create(log_file)

sim_grid_test <- sim_grid |> filter(snr_x == 1, snr_y == 1, p_l < 10000)

tik <- Sys.time()
# Run sim
tryCatch({
  jafar_sim_results <- foreach(i = 1:nrow(sim_grid_test),
                               .combine = bind_rows,
                               .packages = c("tidyverse",
                                             "jafar",
                                             "Rfast")#,
                               # .export = c("load_data",
                               #             "standardize_views",
                               #             "calc_jafar_posterior_means",
                               #             "calc_all_structures",
                               #             "tMCMC",
                               #             "tBurnIn",
                               #             "tThin",
                               #             "mcmc_seed")
  ) %dopar% {
    log_message("Worker:", paste(Sys.info()[['nodename']], Sys.getpid(), sep='-'))
    params <- sim_grid_test[i, ]
    run_and_eval_model(params$n,
                       params$p,
                       params$snr_x,
                       params$snr_y,
                       params$rep,
                       data_path_base,
                       data_name_base,
                       out_path_base,
                       out_name_base)
  }
  
  message("Stopping cluster")
  stopCluster(cl = cluster)
}, error = function(e){
  message(e)
  log_message("Worker:", paste(Sys.info()[['nodename']], Sys.getpid(), sep='-'), e)
  message("Stopping cluster")
  stopCluster(cl = cluster)
}
)
tok <- Sys.time()

print(tok - tik)
```


Debugging
```{r}
i = 1
params <- sim_grid_test[i, ]
run_and_eval_model(params$n,
                       params$p,
                       params$snr_x,
                       params$snr_y,
                       params$rep,
                       data_path_base,
                       data_name_base,
                       out_path_base,
                       out_name_base)


n = params$n
p = params$p
snr_x = params$snr_x
snr_y = params$snr_y
rep = params$rep
in_path_base = data_path_base
in_name_base = data_name_base
out_path_base = out_path_base
out_name_base = out_name_base

#################
# Load + process data
  run_data <- load_data(in_path_base, in_name_base,
                        n, p, snr_x, snr_y, rep)
  X_l <- run_data$X_l
  y <- run_data$y
  X_l.clean <- standardize_views(X_l)
  y.clean <- standardize_outcome(y)
  
  # use default K0. 
  # FIT MODEL
  tik <- Sys.time()
  tryCatch({
  mcmc_supervised <- gibbs_jafar(X_m = X_l.clean, 
                                 y = y.clean, 
                                 # K0=K0, 
                                 # K0_m=c(10, 10, 10),
                                 tMCMC=tMCMC, 
                                 tBurnIn=tBurnIn, 
                                 tThin=tThin,
                                 hyperparams = list(seed = mcmc_seed))
  }, error = function(e) {
    message(e)
    log_message(e)
  })
  tok <- Sys.time()
  runtime <- tok - tik
  
  # Export model
  model_out_data_path <- file.path(out_path_base,
                             "models",
                             sprintf(out_name_base,  n, p, snr_x, snr_y, rep))
  log_message("Writing model:", as.character(model_out_data_path))
  saveRDS(mcmc_supervised,
          model_out_data_path)
  
  tryCatch({
    log_message("Evaluating metrics")
  # Average over MCMC samples
    log_message("→ calc_jafar_posterior_means")
  jafar_posterior_means <- calc_jafar_posterior_means(mcmc_supervised)
  
  # Calculate structures from fitted model and simulated data
  log_message("→ calc_all_structures est_obj")
  est_obj <- calc_all_structures(jafar_posterior_means$shared_scores,
                                 jafar_posterior_means$view_scores,
                                 jafar_posterior_means$shared_loadings,
                                 jafar_posterior_means$view_loadings)
  log_message("→ calc_all_structures sim_obj")
  sim_obj <- calc_all_structures(run_data$Z,
                                 run_data$Phi,
                                 run_data$Lambda_l,
                                 run_data$Gamma_l)
   
  log_message("→ eval_model + bind_rows")
  eval_table <- bind_rows(
    eval_model(est_obj,
               sim_obj,
               "joint_structure",
               "rse"),
    eval_model(est_obj,
               sim_obj,
               "view_structure",
               "rse"),
    eval_model(est_obj,
               sim_obj,
               "data_reconstruction",
               "rse"),
  ) |> 
    mutate(n = n,
           p = p,
           snr_x = snr_x,
           snr_y = snr_y,
           rep = rep,
           time = as.numeric(difftime(tok, tik, units = "secs")))
  
  
  ### Export results
  # eval_table.collected <- bind_rows(eval_table.collected,
  #                                   eval_table)
  metric_out_data_path <- file.path(out_path_base,
                             "metrics",
                             sprintf(out_name_base,  n, p, snr_x, snr_y, rep))
  log_message("Writing metrics:", as.character(metric_out_data_path))
  dir.create(dirname(metric_out_data_path), recursive = TRUE, showWarnings = TRUE)
  stopifnot(exists("eval_table"))
  
  saveRDS(eval_table,
          metric_out_data_path)
  }, error = function(e) {
    message(e)
    log_message(e)
  })

#################
shared_scores = jafar_posterior_means$shared_scores
view_scores = jafar_posterior_means$view_scores
shared_loadings = jafar_posterior_means$shared_loadings
view_loadings = jafar_posterior_means$view_loadings

joint_structure = lapply(1:length(shared_loadings), 
                             function(l) {
                               compute_structure(shared_scores,
                                                 shared_loadings[[l]])
                             }
    )
    view_structure = lapply(1:length(view_scores), 
                            function(l) {
                              compute_structure(view_scores[[l]],
                                                view_loadings[[l]])
                            }
    )
    data_reconstruction = lapply(1:length(view_scores), 
                                 function(l) {
                                   compute_structure(shared_scores,
                                                     view_scores[[l]]) + 
                                     compute_structure(view_scores[[l]],
                                                       view_loadings[[l]])
                                 }
    )
```



```{r}
for (n in n_array) {
  for (p in p_array) {
    for (rep in 1:reps) {
      # Load + process data
      run_data <- load_data(n, p, snr_x, snr_y)
      X_l <- run_data$X_l
      y <- run_data$y
      X_l.clean <- standardize_views(X_l)
      y.clean <- standardize_outcome(y)
      
      # use default K0
      mcmc_supervised <- gibbs_jafar(X_m = X_l.clean, 
                                     y = y.clean, 
                                     # K0=K0, 
                                     # K0_m=c(10, 10, 10),
                                     tMCMC=tMCMC, 
                                     tBurnIn=tBurnIn, 
                                     tThin=tThin,
                                     hyperparams = list(seed = mcmc_seed))
      
      # Average over MCMC samples
      jafar_posterior_means <- calc_jafar_posterior_means(mcmc_supervised)
      
      # Calculate structures from fitted model and simulated data
      est_obj <- calc_all_structures(jafar_posterior_means$shared_scores,
                                     jafar_posterior_means$view_scores,
                                     jafar_posterior_means$shared_loadings,
                                     jafar_posterior_means$view_loadings)
      
      sim_obj <- calc_all_structures(run_data$Z,
                                     run_data$Phi,
                                     run_data$Lambda_l,
                                     run_data$Gamma_l)
      
      eval_table <- bind_rows(
        eval_model(est_obj,
                   sim_obj,
                   "joint_structure",
                   "rse"),
        eval_model(est_obj,
                   sim_obj,
                   "view_structure",
                   "rse"),
        eval_model(est_obj,
                   sim_obj,
                   "data_reconstruction",
                   "rse"),
      ) |> 
        mutate(n = n,
               p = p,
               snr_x = snr_x,
               snr_y = snr_y,
               rep = rep)
      
      eval_table.collected <- bind_rows(eval_table.collected,
                                        eval_table)
      mcmc_objects[paste0("n", n, "p", p, "snrx", snr_x, "snry", snr_y, "rep", rep)] <- mcmc_supervised
      
    }
  }
}
```


```{r}
eval_table.collected |> 
  mutate(n = factor(n),
         l = factor(l),
         p = factor(p)) |> 
  print() |>
  ggplot() +
  geom_point(aes(x = n,
                 y = result,
                 # group = n,
                 color = l)) +
  facet_grid(rows = vars(quantity),
             cols = vars(p),
             scales = "fixed")
```


## Evaluate

Load all metric files and plot

```{r}
getwd()
metric_filenames <- list.files("./results/jafar/metrics/", pattern = "\\.rds$", full.names = TRUE)

jafar_sim_results <- lapply(metric_filenames,
                            function(x) readRDS(x)) |> 
  bind_rows()
```


```{r}
jafar_sim_results |> 
  mutate(n = factor(n),
         l = factor(l),
         p = factor(p)) |> 
  # filter(rep == 1) |> 
  print() |>
  ggplot() +
  # geom_point(aes(x = n,
  #                y = result,
  #                # group = n,
  #                color = l)) +
  geom_boxplot(aes(x = n,
                 y = result,
                 # group = n,
                 color = l)) +
  facet_grid(rows = vars(quantity),
             cols = vars(p),
             scales = "fixed",
             labeller = label_both) + 
  labs(
    title = "Relative squared error of structure and data reconstruction for JAFAR",
    subtitle = TeX("$\\frac{\\|S - \\hat{S}\\| ^{2}}{\\|S \\|^{2}}$")
  )
  
```


```{r}
jafar_sim_results |> 
  group_by(n, p, snr_x, snr_y, rep) |> 
  summarise(mean(time))

jafar_sim_results |> 
  distinct(n, p, snr_x, snr_y, rep, .keep_all = TRUE) |> 
  mutate(n = factor(n),
         l = factor(l),
         p = factor(p)
         ) |>
  # distinct(n, p)
  print() |> 
  ggplot() + 
  geom_boxplot(aes(x = n, y = time)) +
  facet_wrap(~p, labeller = label_both) + 
  labs(
    title = "Wallclock time for JAFAR runs"
  )
```

